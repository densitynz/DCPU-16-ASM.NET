;Initialise stuff (row zero.)
SET J, 0x040
SET [J], 0
ADD J, 1
SET [J], 1
ADD J, 1
SET [J], 0
ADD J, 1

:start
SET I, J        ;Set I as the cell to manipulate.
SET A, 0        ;Initialise loop counter.

:loopone
SUB J, 1        ;Loop start - go backwards through
                ;ram until a row start is found.
ADD A, 1
IFN [J], 0
SET PC, loopone ;Take back to loop if not row start (0x0)

IFN A, 1        ;If row start was not immediate...
SET PC, looptwo ;Go to the second loop.
SET [I], 1      ;If row start was immediate, sets cell to 1.
ADD J, 2        ;Prep. for next cell.
SET PC, start

:looptwo
SUB J, 1        ;Go back through ram,
IFN [J], 0      ;Until a row start is
SET PC, looptwo ;found.

SUB A, 1        ;Go forwards along line above current cell,
ADD J, A        ;but stop 1 short.
ADD [I], [J]    ;Add first.
IFE O, 1        ;If overflow (hence max. rows of Pascal's),
SET PC, crash   ;end it all?
ADD [I], [1+J]  ;Add second.
IFE O, 1        ;Again, is it time to
SET PC, crash   ;break for lunch?

:onechk
IFE [I], 1      ;If 1,
SET PC, lorchk  ;Go to check if last-of-row.

:prep
SET J, I        ;Move J to
ADD J, 1        ;next cell.
SET PC, start

:lorchk
SET J, I        ;Move J to current.
SUB J, 1        ;Move J to check cell before current
IFE [J], 0      ;If current is first-of-row (not last),
SET PC, prep    ;Prep. for next cell.

;last-of-row action.
SET J, I
ADD J, 2        ;If last-of-row, put in row start
SET PC, start   ;(assuming blank RAM.)

:crash
SET PC, crash   ;Hang like a fedora on a hatstand.